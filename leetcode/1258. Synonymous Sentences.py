'''
Given a list of pairs of equivalent words synonyms and a sentence text, Return all possible synonymous sentences sorted lexicographically.
 

Example 1:

Input:
synonyms = [["happy","joy"],["sad","sorrow"],["joy","cheerful"]],
text = "I am happy today but was sad yesterday"
Output:
["I am cheerful today but was sad yesterday",
"I am cheerful today but was sorrow yesterday",
"I am happy today but was sad yesterday",
"I am happy today but was sorrow yesterday",
"I am joy today but was sad yesterday",
"I am joy today but was sorrow yesterday"]
Example 2:

Input: synonyms = [["happy","joy"],["cheerful","glad"]], text = "I am happy today but was sad yesterday"
Output: ["I am happy today but was sad yesterday","I am joy today but was sad yesterday"]
Example 3:

Input: synonyms = [["a","b"],["c","d"],["e","f"]], text = "a c e"
Output: ["a c e","a c f","a d e","a d f","b c e","b c f","b d e","b d f"]
Example 4:

Input: synonyms = [["a","QrbCl"]], text = "d QrbCl ya ya NjZQ"
Output: ["d QrbCl ya ya NjZQ","d a ya ya NjZQ"]
 

Constraints:

0 <= synonyms.length <= 10
synonyms[i].length == 2
synonyms[i][0] != synonyms[i][1]
All words consist of at most 10 English letters only.
text is a single space separated sentence of at most 10 words.
'''

# Using union-find to collect all the synonyms words. After union find, all synonyms words will have a same root which is find(word) as path compression is used in union find.
# Put all synonyms words in a list, if the word doesn't have any synonyms words, put itself in the list. We will have something like this. [ ['I'], ['am'], ['happy', 'joy']]
# Use itertools.product to generate all the combinations.
# Final results can be generated by " ".join and sorted.


#刷題用這個, time complexity O(nlogn), space complexity O(2^10), n = O(2^10) =>  相似句的總數
#思路: 利用union find 來綁定相似詞, 使用defaultdict(set) |= 來連集相似詞的set, 
#技巧: 利用product 搭配 args 來大量產生相似句 => fin_res = [" ".join(sentence) for sentence in product(*res)]
#ex: [['I'], ['am'], ['joy', 'happy', 'cheerful'], ['today'], ['but'], ['was'], ['sorrow', 'sad'], ['yesterday']]
from collections import defaultdict
from itertools import product
class Solution:
    def generateSentences(self, synonyms: List[List[str]], text: str) -> List[str]:
        uf = {} #parents
        
        def union(x, y):
            uf[find(y)] = find(x)
            
        def find(x):
            uf.setdefault(x, x)
            if uf[x]!=x:
                uf[x] = find(uf[x])
            return uf[x]
        
        for a,b in synonyms:
            union(a, b)
            
        d = defaultdict(set)
        for a, b in synonyms:
            root = find(a)
            d[root] |= set([a, b]) # |= set([a, b]) 連集
        txt = text.split()
        res = []
        for t in txt:
            if t not in uf:
                res.append([t])
            else:
                r = find(t)
                res.append(list(d[r]))
        fin_res = [" ".join(sentence) for sentence in product(*res)] #這句太厲害了! 利用product 搭配 args 來大量產生相似句
        return sorted(fin_res)


#itertools.product 用法 => product後 會產生個別的tuple組合
from itertools import product 
  
def cartesian_product(arr1, arr2): 
  
    # return the list of all the computed tuple 
    # using the product() method 
    return list(product(arr1, arr2))  
    
# Driver Function  
if __name__ == "__main__":  
    arr1 = [1, 2, 3] 
    arr2 = [5, 6, 7] 
    print(cartesian_product(arr1, arr2)) 

Output:

[(1, 5), (1, 6), (1, 7), (2, 5), (2, 6), (2, 7), (3, 5), (3, 6), (3, 7)]


#重寫第二次, time complexity O(nlogn), space complexity O(n), n: number of synomous sentences
from collections import defaultdict
from itertools import product
class Solution:
    def generateSentences(self, synonyms: List[List[str]], text: str) -> List[str]:
        u = {}
        
        def find(x):
            u.setdefault(x, x)
            if u[x] != x:
                u[x] = find(u[x])
            return u[x]
            
        def union(x, y):
            u[find(y)] = find(x)
            
        for s in synonyms:
            union(s[0], s[1])
        
        d = defaultdict(set)
        for s in synonyms:
            root = find(s[0])
            d[root] |= set(s)
            
        res = []
        for t in text.split():
            if t not in u:
                res.append([t])
            else:
                res.append(list(d[find(t)]))
        return sorted([" ".join(list(sentence)) for sentence in product(*res)])






